\section{Implementation Details}

This section outlines the engineering decisions made during the development of EduMeter. Every choice is detailed to reflect the team’s commitment to technical excellence and architectural integrity. To ensure a robust codebase, several core design principles were strictly followed, including Don’t Repeat Yourself (\textbf{DRY}), the Single Responsibility Principle (\textbf{SRP}), and the Dependency Inversion Principle (\textbf{DIP}). \\

The implementation phase followed a this approach: use cases were first mapped to a domain model, followed by the design of the business logic. This design-first methodology ended in the final implementation using the Java programming language.

\subsection{Project Dependencies}

The platform relay on several external technologies to operate properly. The choice of these dependencies has been made following the current industrial standard for each one of the components. Particular attention has also been given to the ease of use and maintainability.

\begin{itemize}
	\item \textbf{Maven}: used as build and management tool for the project. 
	\item \textbf{Jakarta RESTful Web Services}: employed as the project's RESTful API specification. 
	\begin{itemize}
		\item \textbf{Jersey}: framework used as core implementation for the jakarta specification, specifically utilizing the jersey-container-servlet module.
		\item \textbf{HK2}: dependency injection engine that manages the lifecycle of Jersey resources and services.
		\item \textbf{Jackson}: handle the serialization and deserialization of Java objects (POJOs) to JSON format.
	\end{itemize}
	\item \textbf{JDBC}: API used for persistent data handling. This allows the Jersey-based backend to perform CRUD operations against the relational database.
	\begin{itemize}
		\item \textbf{PostgreSQL}: concrete implementation of the DB.
	\end{itemize}
	\item \textbf{JUnit Jupiter}: main testing framework. Provides an easy and clear interface to create and run test on the code base.
	\item \textbf{Mockito}: library used with JUnit to isolate components by creating "stubs" or "mocks" of complex dependencies, such as database connectors. 
\end{itemize}

\noindent The project is configured to use Java 17 as the compilation target.

\subsection{Domain Model}

The domain model is that part of the projects that concerns the entity representation in the code base. Each class in responsible for maintaining its own data consistency and displaying a practical and fast interface to provide the client with a safe and reliable experience. The complete UML class diagram is reported at Figure \ref{UML-domain-model}.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[scale=0.7, transform shape]
		\begin{umlpackage}{model}
			\umlclass[x=10, type=abstract]{Review}{
				\begin{tabular}{@{} l l @{}}
					-- id & : Integer \\
					-- creatorHash & : String \\
					-- comment & : String \\
					-- date & : LocalDate \\
					-- enjoyment & : int \\
					-- difficulty & : int 
				\end{tabular}
			}{
				\begin{tabular}{@{} l l @{}}
					+ getters & ... \\
					+ setters & ... 
				\end{tabular}
			}
			
			\umlclass[x=6, y=-7]{DraftedReview}{
				\begin{tabular}{@{} l l @{}}
					-- rawSchool & : String \\
					-- rawDegree & : String \\
					-- rawCourse & : String \\
					-- rawProfessor & : String 
				\end{tabular}
			}{
				\begin{tabular}{@{} l l @{}}
					+ getters & ... \\
					+ setters & ... 
				\end{tabular}
			}
			
			\umlclass[right=2cm of DraftedReview, y=-7]{PublishedReview}{
				\begin{tabular}{@{} l l @{}}
					-- teachingId &: String \\
					-- upvotedByUser &: boolean \\
					-- upvotes &: int 
				\end{tabular}
			}{
				\begin{tabular}{@{} l l @{}}
					+ getters & ... \\
					+ setters & ...
				\end{tabular}
			}
			
			\umlclass[left=5cm of Review]{Admin}{
				\begin{tabular}{@{} l l @{}}
					-- id & : Integer \\
					-- email & : String  
				\end{tabular}
			}{
				\begin{tabular}{@{} l l @{}}
					+ getter & ... \\
					+ setter & ...
				\end{tabular}
			}
			
			\umlclass[below=1cm of Admin]{User}{
				\begin{tabular}{@{} l l @{}}
					-- hash & : String \\
					-- banned & : Boolean  
				\end{tabular}
			}{
				\begin{tabular}{@{} l l @{}}
					+ getter & ... \\
					+ setter & ...
				\end{tabular}
			}
			
			\umlclass[below=1cm of User]{Report}{
				\begin{tabular}{@{} l l @{}}
					-- id & : Integer \\
					-- comment & : String \\
					-- date & : LocalDate \\
					-- issuerHash & : String \\
					-- reviewId & : int   
				\end{tabular}
			}{
				\begin{tabular}{@{} l l @{}}
					+ getter & ... \\
					+ setter & ...
				\end{tabular}
			}
			
			\umlclass[below=1cm of Report]{PinChallenge}{
				\begin{tabular}{@{} l l @{}}
					-- id & : Integer \\
					-- pin & : String \\
					-- userHash & : String \\
					-- expiresAt & : Instant \\
					-- admin & : boolean   
				\end{tabular}
			}{
				\begin{tabular}{@{} l l @{}}
					+ getter & ... \\
					+ setter & ...
				\end{tabular}
			}
			
			\umlclass[below=1cm of PinChallenge, type=record]{Token}{
				\begin{tabular}{@{} l l @{}}
					-- userHash & : String \\
					-- expiresAt & : long \\
					-- isAdmin & : boolean   
				\end{tabular}
			}{}
			
			\umlclass[right=5cm of Review]{School}{
				\begin{tabular}{@{} l l @{}}
					-- id & : Integer \\
					-- name & : String 
				\end{tabular}
			}{
				\begin{tabular}{@{} l l @{}}
					+ getter & ... \\
					+ setter & ...
				\end{tabular}
			}
			
			\umlclass[below=1cm of School]{Degree}{
				\begin{tabular}{@{} l l @{}}
					-- id & : Integer \\
					-- name & : String \\
					-- type & : Type \\
					-- schoolId & : int 
				\end{tabular}
			}{
				\begin{tabular}{@{} l l @{}}
					+ getter & ... \\
					+ setter & ...
				\end{tabular}
			}
			
			\umlclass[below=1cm of Degree]{Course}{
				\begin{tabular}{@{} l l @{}}
					-- id & : Integer \\
					-- name & : String \\
					-- degreeId & : int 
				\end{tabular}
			}{
				\begin{tabular}{@{} l l @{}}
					+ getter & ... \\
					+ setter & ...
				\end{tabular}
			}
			
			\umlclass[below=1cm of Course]{Professor}{
				\begin{tabular}{@{} l l @{}}
					-- id & : Integer \\
					-- name & : String \\
					-- surname & : String 
				\end{tabular}
			}{
				\begin{tabular}{@{} l l @{}}
					+ getter & ... \\
					+ setter & ...
				\end{tabular}
			}
			
			\umlclass[below=1cm of Professor]{Teaching}{
				\begin{tabular}{@{} l l @{}}
					-- id & : Integer \\
					-- profId & : Integer \\
					-- courseId & : Integer 
				\end{tabular}
			}{
				\begin{tabular}{@{} l l @{}}
					+ getter & ... \\
					+ setter & ...
				\end{tabular}
			}
			
			\begin{umlpackage}[x=8, y=-14]{response}
				\umlclass[type=record]{ApiError}{
					-- error : String
				}{}
				\umlclass[type=record, right=1cm of ApiError]{ApiObjectCreated}{
					\begin{tabular}{@{} l l @{}}
						-- message & : string \\
						-- id & : int 
					\end{tabular}
				}{}
				\umlclass[type=record, below=1cm of ApiError]{ApiOk}{
					-- message : String
				}{}
			\end{umlpackage}
			
		\end{umlpackage}
		
		\umlinherit[geometry=|-|, anchor1=north, anchor2 = south]{DraftedReview}{Review}
		\umlinherit[geometry=|-|, anchor1=north, anchor2 = south]{PublishedReview}{Review}
	\end{tikzpicture}
	\caption{UML class diagram of the domain model}
	\label{UML-domain-model}
\end{figure}

\paragraph{\textbf{Resemblance with the ER model.}} The classes has been designed to align almost perfectly with their counter part in the database, simplifying and speeding up the DB queries. Composition, in other words, nested objects, are entirely avoided using the object's DB IDs.  

\subsection{Business Logic}

This package is responsible for the heavy lifting of the backend's functional duties. The logic has been divided into three distinct components, each providing a fundamental service to the entire project: \textbf{authentication service}, \textbf{resource controllers} and \textbf{exception handlers}. These three packages actively engage with each other and with the ORM, which will be explored in section \ref{ORM-section}.

\subsubsection{Authentication and Authorization Service}
In EduMeter, users and admins needs to authenticate in order to perform their specific actions (publication and management). The authentication and authorization system is designed as a stateless, token-based security layer integrated into the JAX-RS request lifecycle. This design ensures secure communication and fine access control without the need for server-side session state. Follows a description of all the structural decisions made by the team to implement this service. A detailed UML package diagram is also provided.

\paragraph{Declarative Security and Name Binding.}
To secure REST endpoints, the system utilizes a declarative approach through custom annotations, making the code lighter and less repetitive, avoiding boiler plate control sequences. We have created 2 annotations:
\begin{itemize}
	\item \textbf{@AuthGuard}: Applied to resources requiring standard user authentication (e.g up-voting reviews and creating reviews).
	\item \textbf{@AdminGuard}: Applied to resources restricted to moderators (e.g. draft review and validation, report solving and behavioral countermeasures).
	\item \textbf{Name Binding}: Both annotations utilize the \texttt{@NameBinding} meta-annotation, allowing the JAX-RS runtime to dynamically associate specific filters with annotated resource methods.
\end{itemize}

\paragraph{Request Filtering and Context Injection.}
The security workflow is managed by two primary providers that intercept incoming traffic:
\begin{itemize}
	\item \textbf{AuthFilter}: This component intercepts requests marked with \texttt{@AuthGuard}. It extracts the \texttt{Bearer} token (a digital "entry pass" that identifies a user and their permissions automatically, allowing the system to verify them without needing to check a database every time) from the \texttt{Authorization} header and initiates validation through the \texttt{CryptoService}. Upon successful verification, it injects a custom \texttt{SecurityContext} into the request, establishing the user principal and defining roles such as \texttt{ADMIN} or \texttt{BASE}.
	\item \textbf{AdminFilter}: This filter extends \texttt{AuthFilter} to handle \texttt{@AdminGuard} requirements. It first executes the base authentication logic via \texttt{super.filter()} and then performs a secondary check to ensure the authenticated principal possesses the \texttt{ADMIN} role. Failure to meet this requirement results in a \texttt{ForbiddenException} (HTTP 403).
\end{itemize}

\paragraph{The Cryptographic Engine (CryptoService).}
The \texttt{CryptoService} serves as a singleton utility responsible for the platform's cryptographic operations.
\begin{itemize}
	\item \textbf{JWT Custom Design}: The service implements a simplified version of the JSON Web Token (JWT) concept. To reduce overhead, the standard JWT header is omitted, resulting in a two-part token (instead of three-part) consisting of a Base64-encoded JSON payload and an HMAC-SHA256 signature.
	\item \textbf{Signature Verification}: Tokens are signed using the \texttt{HmacSHA256} algorithm and a server-side secret. Validation uses \texttt{MessageDigest.isEqual} to compare signatures, providing protection against timing attacks.
	\item \textbf{User Anonymization}: One of the core EduMeter's features is complete user anonymity, user's sensitive information are never visible to other users nor admins and are never stored directly into the DB. To protect privacy while maintaining database efficiency, the service generates a \texttt{userHash}. This is achieved by computing a 16-byte truncated version of an HMAC-SHA256 hash of the user's email, resulting in a unique 22-character Base64 identifier.
\end{itemize}

\paragraph{Token Lifecycle and Security Constraints.}
\begin{itemize}
	\item \textbf{Expiration}: Tokens are generated with a strict 30-minute validity window.
	\item \textbf{Revocation}: A \texttt{revokedTokens} set is maintained to handle logout events or compromised tokens. While currently implemented using a \texttt{ConcurrentHashMap}, the service is designed for future migration to a Redis-based key store for persistent, distributed revocation management.
	\item \textbf{Secret Management}: The system requires a \texttt{SECRET} environment variable; if missing, it falls back to a randomly generated secure secret, ensuring that keys are invalidated upon every deployment for security.
\end{itemize}

\begin{figure}
	\centering
	\begin{tikzpicture}[scale=0.7, transform shape]
		\umlclass[type= Jakarta interface, x=10, y=3]{ContainerRequestFilter}{}{}
		
		\begin{umlpackage}[y=-2]{auth}
			\begin{umlpackage}{annotations}
				\umlclass[type=@interface]{AuthGuard}{}{}
				\umlclass[right=2cm of AuthGuard, type=@interface]{AdminGuard}{}{}
			\end{umlpackage}
			
			\begin{umlpackage}[x=13, y=0]{filters}
				\umlclass{AuthFilter}{}{
					+ filter(...) : void
				}
				\umlclass[right=2cm of AuthFilter]{AdminFilter}{}{
					+ filter(...) : void
				}
			\end{umlpackage}
			
			\umlclass[x=12, y=-6, type = Singleton]{CryptoService}{
				\begin{tabular}{@{} l l @{}}
					-- static final TOKEN\_EXPIRE\_MINUTES & : long \\
					-- static final HMAC\_ALGO & : String           \\
					-- static instance & : CryptoSerice             \\
					-- final jsonMapper & : ObjectMapper            \\
					-- final mac & : Mac                            \\
					-- final revokedTokens & : Set<String>
				\end{tabular}
			}{
				\begin{tabular}{@{} l l @{}}
					-- CryptoService() & : CryptoService            \\
					+ static sync getInstance() & : CryptoService   \\
					+ generateToken(String, boolean) & : String     \\
					+ decodeToken(String) & : Token                 \\
					+ revokeToken(String) & : void                  \\
					+ getUserId(String) & : String 
				\end{tabular}         
			}
			
			\umlclass[x=2, y=-6,type=record]{Token}{
				\begin{tabular}{@{} l l @{}}
					+ userHash & : String \\
					+ expiresAt & : long \\
					+ isAdmin & : boolean 
				\end{tabular}
			}{}
		\end{umlpackage}
		
		\umlinherit[anchor1=west, anchor2=east]{AdminFilter}{AuthFilter}
		\umldep[anchor1=west, anchor2=east, stereo=use]{CryptoService}{Token}
		\umlimpl[geometry=-|]{AuthFilter}{ContainerRequestFilter}
	\end{tikzpicture}
	\caption{UML class diagram of the authentication package}
	\label{UML-auth}
\end{figure}

\subsubsection{Resource Controllers}

\begin{figure}
	\centering
	\begin{tikzpicture}[scale=0.6, transform shape]
		\begin{umlpackage}{controllers}
			\umlclass{AdminController}{
				- adminDAO : AdminDAO \\
			}{
			    \begin{tabular}{@{} l l @{}}
			    	+ getAll() & : List<Admin> \\
			    	+ get(int) & : Admin \\
			    	+ create(Admin) & : ApiObjectCreated \\
			    	+ delete(int) & : ApiOK 
			    \end{tabular}
				
			}
			
			\umlclass[right=0.7cm of AdminController]{UserController}{
				+ userDAO : UserDAO \\
			}{
				\begin{tabular}{@{} l l @{}}
					+ search(Boolean) & : List<User> \\
					+ getByHash(SecurityContext) & : User \\
					+ ban(String) & : Boolean \\
				\end{tabular}
			}
			
			\umlclass[right=0.7cm of UserController]{AuthController}{
				\begin{tabular}{@{} l l @{}}
					+ \underline{WHITELISTED\_DOMAINS} & : String \\
					+ \underline{PIN\_EXPIRATION\_MIN} & : int \\
					-- pinDAO & : PinDAO \\
					-- adminDAO & : AdminDAO \\
					-- record SendPinBody(String) & \\
					-- record LoginBody(String, String) & \\
					-- record LoginResponse(String) & 
				\end{tabular}
			}{
				\begin{tabular}{@{} l l @{}}
					+ sendPin(boolean, SendPinBody) & : ApiOK \\
					+ login(boolean, LoginBody) & : LogicResponse \\
					+ logout(String) & : ApiOK
				\end{tabular}
			}
			
			\umlclass[x=4, y=-12]{ReportController}{
				\begin{tabular}{@{} l l @{}}
					-- reportDAO & : ReportDAO \\
					-- userDAO & : UserDAO
				\end{tabular}
			}{
				\begin{tabular}{@{} l l @{}}
					+ getAll() & : List<Report> \\
					+ get(int) & : Report \\
					+ create(SecurityContext, Report) & : CreateResponse \\
					+ acceptReport(int,Boolean) & : void
				\end{tabular}
			}
			
			\umlclass[x=0.5, y=-6]{DegreeController}{
				-- degreeDAO : DegreeDAO
			}{
				\begin{tabular}{@{} l l @{}}
					+ search(String, Integer) & : List<Degree> \\
					+ get(int) & : Degree \\
					+ create(Degree) & : CreateResponse \\
					+ delete(int) & : ApiOK \\
					+ update(Degree) & : ApiOK
				\end{tabular}
			}
			
			\umlclass[right=0.5cm of DegreeController,y=-3]{SchoolController}{
				-- schoolDAO : SchoolDAO
			}{
				\begin{tabular}{@{} l l @{}}
					+ search(String) & : List<School> \\
					+ get(int) & : School \\
					+ create(School) & : CreateResponse \\
					+ delete(int) & : ApiOK \\
					+ update(School) & : ApiOK
				\end{tabular}
			}
			
			\umlclass[right=0.5cm of SchoolController, y=-3]{CourseController}{
				-- courselDAO : courseDAO
			}{
				\begin{tabular}{@{} l l @{}}
					+ search(String, Integer, Integer) & : List<Course> \\
					+ get(int) & : Course \\
					+ create(Course) & : CreateResponse \\
					+ delete(int) & : ApiOK \\
					+ update(Course) & : ApiOK
				\end{tabular}
			}
			
			\umlclass[right=2cm of ReportController]{ProfessorController}{
				\begin{tabular}{@{} l l @{}}
					-- profDAO & : ProfDAO \\
					-- teachingDAO & : TeachingDAO
				\end{tabular}
			}{
				\begin{tabular}{@{} l l @{}}
					+ search(String, Integer) & : List<Professor> \\
					+ get(int) & : Professor \\
					+ create(Professor) & : ApiObjectCreated \\
					+ delete(int) & : ApiOk \\
					+ update(Professor) & : ApiOk \\
					+ listTeachings(int) & : List<Teaching>
				\end{tabular}
			}
			
			\umlclass[x=3,y=-18]{PublishedReviewController}{
				+ publishedReviewDAO : PublishedReviewDAO
			}{
				\begin{tabular}{@{} l l @{}}
					+ search(Integer, ..., Integer, ContainerRequestContext) & : List<T> \\
					+ get(int, ContainerRequestContext) & : PublishedReview \\
					+ publish(PublishedReview, SecurityContext) & : ApiObjectCreated \\
					+ toggleVote(int, ContainerRequestContext) & : ApiOk \\
					+ delete(int, ContainerRequestContext) & : ApiOk \\
					+ update(PublishedReview, ContainerRequestContext) & : ApiOk \\
				\end{tabular}
			}
			
			\umlclass[right=2cm of PublishedReviewController,y=-6]{DraftReviewController}{
				-- reviewDAO : DraftReviewDAO
			}{
				\begin{tabular}{@{} l l @{}}
					+ getAll() & : List<DraftReview> \\
					+ get(int) &  : DraftReview \\
					+ publish(DraftReview, SecurityContext) & : ApiObjectCreated \\
					+ delete(int) & : ApiOk
				\end{tabular}
			}
			
		\end{umlpackage}
	\end{tikzpicture}
	\caption{UML class diagram of the resource controllers package}
	\label{UML-controllers}
\end{figure}

\subsubsection{Exception Handlers}
The \textbf{Exception Handlers} package is a fundamental component of the \textit{EduMeter} architecture, responsible for ensuring system robustness and providing a consistent interface for error reporting.

\paragraph{\textbf{Standardized Error Reporting.}}
To prevent the leakage of sensitive internal state and to provide a predictable API for client-side consumption, this package intercepts all application-level exceptions and translates them into a standardized JSON format: \texttt{\{"error":"description of the issue"\}}. This mechanism ensures that the backend never returns default HTML error pages.

\paragraph{\textbf{Specialized Exception Mappers.}}
The package utilizes the Jakarta \texttt{ExceptionMapper} interface to provide in-depth control over different error scenarios:

\begin{itemize}
	\item \textbf{Global Exception Handler}: Acts as a universal safety net for any \texttt{Throwable} not caught by more specific mappers. It preserves the HTTP status codes for \texttt{WebApplicationExceptions} while mapping all other unforeseen errors to HTTP 500 (Internal Server Error).
	\item \textbf{JSON Validation Mappers}: Specialized mappers such as \texttt{JsonParseExceptionHandler} and \texttt{UnrecognizedPropertyExceptionHandler} handle errors related to request payloads. These mappers return HTTP 400 (Bad Request), providing specific feedback when a client sends malformed JSON or invalid data fields.
\end{itemize}

The exception handling in JAX-RS operates through a hierarchical discovery process that prioritizes the most specific match available to resolve a failure. When an error occurs, the runtime builds a map of all classes annotated with \texttt{@Provider} and searches for an ExceptionMapper that matches the thrown exception type, starting from the most narrow "leaf" class and moving up the inheritance tree toward more general types. In the \textit{EduMeter} implementation, this allows specialized handlers to capture precise issues, such as malformed data or unrecognized fields, and provide detailed feedback with an HTTP 400 status. If no specific mapper is found, the system falls back to a global Throwable handler that serves as a safety net, ensuring that even unforeseen internal errors are caught and translated into a standardized JSON response rather than exposing raw system details.

\begin{figure}
	\centering
	\begin{tikzpicture}[scale=0.8, transform shape]
		
		\umlclass[x=-4, y=6]{ExceptionMapper<Throwable>}{}{}
		\umlclass[x=5, y=6]{ExceptionMapper<InvalidFormat>}{}{}
		
		\umlclass[x=-4, y=-5]{ExceptionMapper<JsonParseException>}{}{}
		\umlclass[x=6, y=-5]{ExceptionMapper<UnrecognizedPropertyException>}{}{}
		
		\begin{umlpackage}[x=0.5, y=-8]{exceptionHandlers}
			
			\umlclass[x=-4.5, y=10]{ExceptionHandler}
			{}
			{+ toResponse(Throwable) : Response}
			
			\umlclass[x=4.5, y=10]{InvalidFormatExceptionHandler}
			{}
			{+ toResponse(Throwable) : Response}
			
			\umlclass[x=-4.5, y=7]{JsonParseExceptionHandler}
			{}
			{+ toResponse(Throwable) : Response}
			
			\umlclass[x=4.5, y=7]{UnrecognizedPropertyExceptionHandler}
			{}
			{+ toResponse(Throwable) : Response}
			
			\umlinherit[geometry=|-|, anchor1=30, anchor2=-50]{ExceptionHandler}{ExceptionMapper<Throwable>}
			\umlinherit{InvalidFormatExceptionHandler}{ExceptionMapper<InvalidFormat>}
			\umlinherit{JsonParseExceptionHandler}{ExceptionMapper<JsonParseException>}
			\umlinherit[geometry=|-|]{UnrecognizedPropertyExceptionHandler}{ExceptionMapper<UnrecognizedPropertyException>}
			
		\end{umlpackage}
		
	\end{tikzpicture}
	\label{UML-exceptin-handling}
	\caption{UML class diagram of the exception handling package}
\end{figure}

\paragraph{\textbf{Approach Advantages.}}
Implementing multiple specialized mappers instead of a single general safety net provides several engineering advantages:
\begin{itemize}
	\item \textbf{Precise Client Feedback}: Clients receive exact details about validation errors (such as the specific unrecognized field name) rather than a vague "Internal Error".
	\item \textbf{Semantic HTTP Accuracy}: This approach ensures that client-side mistakes correctly return HTTP 400 (Bad Request) codes, whereas a single safety net might incorrectly categorize them as 500 (Internal Server Error).
	\item \textbf{Security and Sanitization}: Specific mappers allow for "sanitizing" error messages to ensure that internal database structures or logic are not leaked, while the general handler prevents the exposure of raw stack traces.
	\item \textbf{Operational Efficiency}: Decoupling error handling from business logic allows core services to focus on the "happy path," while the provider architecture automatically manages the complexity of error translation at the edge of the application.
\end{itemize}

\subsection{Object-Relation Mapper (ORM)} \label{ORM-section}

\subsubsection{DAO Interfaces}

\begin{figure}
	\centering
	\begin{tikzpicture}[scale=0.7, transform shape]
		\begin{umlpackage}{ORM}
			\umlclass[type=interface]{DAOFactory}{}{
				\begin{tabular}{@{} l l @{}}
					... & ... \\
					+ getDegreeDAO() & : DegreeDAO \\
					... & ...
				\end{tabular}
			}
			\umlclass[type=interface, right=3.5cm of DAOFactory]{AdminDAO}{}{
				\begin{tabular}{@{} l l @{}}
					+ get(int) & : Optional<Admin> \\
					+ getByEmail(String) & : Optional<Admin> \\
					+ getAll() & : List<Admin> \\
					+ delete(int) & : void \\
					+ add(Admin) & : int 
				\end{tabular}
			}
			\umlclass[x=7.5, y=-5]{InMemAdminDAO}{}{}
			\umlclass[right=2.16cm of InMemAdminDAO]{PostgreAdminDAO}{}{}
			
			\umlclass[type=interface, x=7.5, y=-8]{InMemDAOFactory}{}{}
			\umlclass[type=interface, right=2cm of InMemDAOFactory]{PostgreDAOFactory}{}{}
			
		\end{umlpackage}
		
		\umldep[geometry=|-|]{InMemDAOFactory}{InMemAdminDAO}
		\umldep[geometry=|-|]{PostgreDAOFactory}{PostgreAdminDAO}
		\umldep[anchor1=east, anchor2=west]{DAOFactory}{AdminDAO}
		
		\umlinherit[geometry=|-|, arm1=1, anchor1=north]{InMemAdminDAO}{AdminDAO}
		\umlinherit[geometry=|-|, arm1=1, anchor1=north]{PostgreAdminDAO}{AdminDAO}
		
		\umlinherit[geometry=|-|, anchor1=south, arm1=-0.3]{InMemDAOFactory}{DAOFactory}
		\umlinherit[geometry=|-|, anchor1=south, arm1=-0.3]{PostgreDAOFactory}{DAOFactory}
	\end{tikzpicture}
	\caption{Partial UML class diagram of the ORM package. This diagram display only the portion related to the Admin resource, the part referred to the other resources have the exact layout, therefore, it is omitted.}
	\label{UML-ORM}
\end{figure}

\subsubsection{In Memory Storage}

\subsubsection{Postgre Remote Storage}

\subsection{Database}

\begin{figure}
	\centering
	\begin{tikzpicture}

		\umlclass{User}{
			% The @{} removes extra side padding for a tighter fit
			\begin{tabular}{@{} l l l @{}}
				\textbf{PK} & \textbf{id} & \textit{int} \\
					    	& banned      & \textit{boolean}
			\end{tabular}
		}{}


		\umlclass[below = 1cm of User]{Report}{
			\begin{tabular}{@{} l l l @{}}
				\textbf{PK} & \textbf{id} & \textit{int} \\
					    	& comment     & \textit{varchar} \\
					    	& date        & \textit{date} \\
				\textbf{FK} & user\_id    & \textit{int} \\
				\textbf{FK} & review\_id  & \textit{int}
			\end{tabular}
		}{}

		\umlclass[right = 1cm of User]{Drafted Review}{
			\begin{tabular}{@{} l l l @{}}
				\textbf{PK} & \textbf{id} & \textit{int} \\
						    & comment     & \textit{varchar} \\
						    & date        & \textit{date} \\
						    & rating      & \textit{int} \\
						    & difficulty  & \textit{int} \\
						    & school      & \textit{varchar} \\
						    & degree      & \textit{varchar} \\
						    & course      & \textit{varchar} \\
						    & professor   & \textit{varchar} \\
				\textbf{FK} & user\_id    & \textit{int} \\
			\end{tabular}
		}{}

		\umlclass[below = 1cm of Drafted Review]{Published Review}{
			\begin{tabular}{@{} l l l @{}}
				\textbf{PK} & \textbf{id}   & \textit{int} \\
						    & comment       & \textit{varchar} \\
						    & date          & \textit{date} \\
						    & rating        & \textit{int} \\
						    & difficulty    & \textit{int} \\
				\textbf{FK} & course\_id    & \textit{int} \\
				\textbf{FK} & professor\_id & \textit{int} \\ 
				\textbf{FK} & user\_id      & \textit{int} \\
			\end{tabular}
		}{}

		\umlclass[below = 1cm of Published Review]{Teaching}{
			\begin{tabular}{@{} l l l @{}}
				\textbf{PK FK} & \textbf{course\_id}    & \textit{int} \\
				\textbf{PK FK} & \textbf{professor\_id} & \textit{int} \\
			\end{tabular}
		}{}

		\umlclass[right = 1cm of Teaching]{Course}{
		    \begin{tabular}{@{} l l l @{}}
				\textbf{PK} & \textbf{id} & \textit{int} \\
						    & name        & \textit{varchar} \\
				\textbf{FK} & degree\_id  & \textit{int} \\
		    \end{tabular}
		}{}

		\umlclass[above = 1cm of Course]{Degree}{
		    \begin{tabular}{@{} l l l @{}}
				\textbf{PK} & \textbf{id} & \textit{int} \\
						    & name        & \textit{varchar} \\
						    & type        & \textit{varchar} \\
				\textbf{FK} & school\_id  & \textit{int} \\
		    \end{tabular}
		}{}

		\umlclass[above = 1cm of Degree]{School}{
		    \begin{tabular}{@{} l l l @{}}
				\textbf{PK} & \textbf{id} & \textit{int} \\
						    & name        & \textit{varchar} \\
		    \end{tabular}
		}{}

		\umlclass[left = 1cm of Teaching]{Professor}{
		    \begin{tabular}{@{} l l l @{}}
				\textbf{PK} & \textbf{id} & \textit{int} \\
						    & name        & \textit{varchar} \\
						    & surname     & \textit{varchar} \\
		    \end{tabular}
		}{}

		\umlclass[above = 2cm of School]{Admin}{
		    \begin{tabular}{@{} l l l @{}}
				\textbf{PK} & \textbf{id} & \textit{int} \\
						    & email       & \textit{varchar} \\
		    \end{tabular}
		}{}

		\umluniassoc{Report}{User}
		\umluniassoc{Drafted Review}{User}
		\umluniassoc[geometry=-|-]{Published Review}{User}
		\umluniassoc{Course}{Degree}
		\umluniassoc{Degree}{School}
		\umluniassoc{Teaching}{Course}
		\umluniassoc{Teaching}{Professor}
		\umluniassoc{Published Review}{Teaching}

	\end{tikzpicture}
	\caption{UML diagram of Database schema}
\end{figure}

\subsection{Interface}
