\section{Implementation Details}
This section outlines the engineering decisions made during the development of EduMeter. Every choice is detailed to reflect the team’s commitment to technical excellence and architectural integrity. To ensure a robust codebase, several core design principles were strictly followed, including Don’t Repeat Yourself (\textbf{DRY}), the Single Responsibility Principle (\textbf{SRP}), and the Dependency Inversion Principle (\textbf{DIP}). \\

The implementation phase followed this approach: use cases were first mapped to a domain model, followed by the design of the business logic, ending with the persistent relational database. This design-first methodology ended in the final implementation using the Java programming language.

\subsection{Project Dependencies}
The platform relay on several external technologies to operate properly. The choice of these dependencies has been made following the current industrial standard for each one of the components. Particular attention has also been given to the ease of use and maintainability.

\begin{itemize}
	\item \textbf{Maven}: used as build and management tool for the project. 
	\item \textbf{Jakarta RESTful Web Services}: employed as the project's RESTful API specification. 
	\begin{itemize}
		\item \textbf{Jersey}: framework used as core implementation for the jakarta specification, specifically utilizing the jersey-container-servlet module.
		\item \textbf{HK2}: dependency injection engine that manages the lifecycle of Jersey resources and services.
		\item \textbf{Jackson}: handle the serialization and deserialization of Java objects (POJOs) to JSON format.
	\end{itemize}
	\item \textbf{JDBC}: API used for persistent data handling. This allows the Jersey-based backend to perform CRUD operations against the relational database.
	\begin{itemize}
		\item \textbf{PostgreSQL}: concrete implementation of the DB.
	\end{itemize}
	\item \textbf{JUnit Jupiter}: main testing framework. Provides an easy and clear interface to create and run test on the code base.
	\item \textbf{Mockito}: library used with JUnit to isolate components by creating mocks of complex dependencies, such as database connectors. 
\end{itemize}

\noindent The project is configured to use Java 17 as the compilation target.

\subsection{Project Structure}
The project has a standard structure divided into two parts: main and test. Both the parts got the same directory layout and file's name scheme \textbf{TODO: WRITE WHY THE STRUCTURE MUST BE SYMMETRIC}. As highlighted by the directory tree (Figure \ref{fig:tree}), the project is realized following the system architecture described in section \ref{system-architecture-section}. Inside each one of the modules there are the directories containing the packages reported in the overall UML diagram in Figure \ref{UML-overall-diagram}.

\begin{figure}[h]
	\small
	\begin{minipage}{0.8\textwidth}
		\dirtree{%
			.1 src.
			.2 main.
			.3 java.
			.4 com.swe.EduMeter.
			.5 business\_logic.
			.6 auth.
			.7 annotations.
			.7 filters.
			.6 controllers.
			.6 exception\_handlers.
			.6 MainApplication.class.
			.5 model.
			.6 classes.
			.6 response.
			.5 orm.
			.6 in\_mem.
			.6 postgres.
			.6 DAO.
			.3 resources.
			.4 init.sql.
			.2 test.
			.3 java.
			.4 com.swe.EduMeter.
			.5 business\_logic.
			.6 controllers.
			.6 ....
			.5 model.
			.6 ....
			.5 orm.
			.6 ....
		}
	\end{minipage}
	\caption{EduMeter Project Directory Structure}
	\label{fig:tree}
\end{figure}

\subsection{Domain Model}
The domain model is that part of the projects that concerns the entity representation in the code base. Each class in responsible for maintaining its own data consistency and displaying a practical and fast interface to provide the client with a safe and reliable experience. The complete UML class diagram is reported at Figure \ref{UML-domain-model}.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[scale=0.7, transform shape]
		\begin{umlpackage}{model}
			\umlclass[x=10, type=abstract]{Review}{
				\begin{tabular}{@{} l l @{}}
					-- id & : Integer \\
					-- creatorHash & : String \\
					-- comment & : String \\
					-- date & : LocalDate \\
					-- enjoyment & : int \\
					-- difficulty & : int 
				\end{tabular}
			}{
				\begin{tabular}{@{} l l @{}}
					+ getters & ... \\
					+ setters & ... 
				\end{tabular}
			}
			
			\umlclass[x=6, y=-7]{DraftedReview}{
				\begin{tabular}{@{} l l @{}}
					-- rawSchool & : String \\
					-- rawDegree & : String \\
					-- rawCourse & : String \\
					-- rawProfessor & : String 
				\end{tabular}
			}{
				\begin{tabular}{@{} l l @{}}
					+ getters & ... \\
					+ setters & ... 
				\end{tabular}
			}
			
			\umlclass[right=2cm of DraftedReview, y=-7]{PublishedReview}{
				\begin{tabular}{@{} l l @{}}
					-- teachingId &: String \\
					-- upvotedByUser &: boolean \\
					-- upvotes &: int 
				\end{tabular}
			}{
				\begin{tabular}{@{} l l @{}}
					+ getters & ... \\
					+ setters & ...
				\end{tabular}
			}
			
			\umlclass[left=5cm of Review]{Admin}{
				\begin{tabular}{@{} l l @{}}
					-- id & : Integer \\
					-- email & : String  
				\end{tabular}
			}{
				\begin{tabular}{@{} l l @{}}
					+ getter & ... \\
					+ setter & ...
				\end{tabular}
			}
			
			\umlclass[below=1cm of Admin]{User}{
				\begin{tabular}{@{} l l @{}}
					-- hash & : String \\
					-- banned & : Boolean  
				\end{tabular}
			}{
				\begin{tabular}{@{} l l @{}}
					+ getter & ... \\
					+ setter & ...
				\end{tabular}
			}
			
			\umlclass[below=1cm of User]{Report}{
				\begin{tabular}{@{} l l @{}}
					-- id & : Integer \\
					-- comment & : String \\
					-- date & : LocalDate \\
					-- issuerHash & : String \\
					-- reviewId & : int   
				\end{tabular}
			}{
				\begin{tabular}{@{} l l @{}}
					+ getter & ... \\
					+ setter & ...
				\end{tabular}
			}
			
			\umlclass[below=1cm of Report]{PinChallenge}{
				\begin{tabular}{@{} l l @{}}
					-- id & : Integer \\
					-- pin & : String \\
					-- userHash & : String \\
					-- expiresAt & : Instant \\
					-- admin & : boolean   
				\end{tabular}
			}{
				\begin{tabular}{@{} l l @{}}
					+ getter & ... \\
					+ setter & ...
				\end{tabular}
			}
			
			\umlclass[below=1cm of PinChallenge, type=record]{Token}{
				\begin{tabular}{@{} l l @{}}
					-- userHash & : String \\
					-- expiresAt & : long \\
					-- isAdmin & : boolean   
				\end{tabular}
			}{}
			
			\umlclass[right=5cm of Review]{School}{
				\begin{tabular}{@{} l l @{}}
					-- id & : Integer \\
					-- name & : String 
				\end{tabular}
			}{
				\begin{tabular}{@{} l l @{}}
					+ getter & ... \\
					+ setter & ...
				\end{tabular}
			}
			
			\umlclass[below=1cm of School]{Degree}{
				\begin{tabular}{@{} l l @{}}
					-- id & : Integer \\
					-- name & : String \\
					-- type & : Type \\
					-- schoolId & : int 
				\end{tabular}
			}{
				\begin{tabular}{@{} l l @{}}
					+ getter & ... \\
					+ setter & ...
				\end{tabular}
			}
			
			\umlclass[below=1cm of Degree]{Course}{
				\begin{tabular}{@{} l l @{}}
					-- id & : Integer \\
					-- name & : String \\
					-- degreeId & : int 
				\end{tabular}
			}{
				\begin{tabular}{@{} l l @{}}
					+ getter & ... \\
					+ setter & ...
				\end{tabular}
			}
			
			\umlclass[below=1cm of Course]{Professor}{
				\begin{tabular}{@{} l l @{}}
					-- id & : Integer \\
					-- name & : String \\
					-- surname & : String 
				\end{tabular}
			}{
				\begin{tabular}{@{} l l @{}}
					+ getter & ... \\
					+ setter & ...
				\end{tabular}
			}
			
			\umlclass[below=1cm of Professor]{Teaching}{
				\begin{tabular}{@{} l l @{}}
					-- id & : Integer \\
					-- profId & : Integer \\
					-- courseId & : Integer 
				\end{tabular}
			}{
				\begin{tabular}{@{} l l @{}}
					+ getter & ... \\
					+ setter & ...
				\end{tabular}
			}
			
			\begin{umlpackage}[x=8, y=-14]{response}
				\umlclass[type=record]{ApiError}{
					-- error : String
				}{}
				\umlclass[type=record, right=1cm of ApiError]{ApiObjectCreated}{
					\begin{tabular}{@{} l l @{}}
						-- message & : string \\
						-- id & : int 
					\end{tabular}
				}{}
				\umlclass[type=record, below=1cm of ApiError]{ApiOk}{
					-- message : String
				}{}
			\end{umlpackage}
			
		\end{umlpackage}
		
		\umlinherit[geometry=|-|, anchor1=north, anchor2 = south]{DraftedReview}{Review}
		\umlinherit[geometry=|-|, anchor1=north, anchor2 = south]{PublishedReview}{Review}
	\end{tikzpicture}
	\caption{UML class diagram of the domain model.}
	\label{UML-domain-model}
\end{figure}

\paragraph{\textbf{Resemblance with the ER model.}} The classes are designed to align closely with their database counterparts, which simplifies and accelerates DB queries. To maintain this alignment, composition (nested objects) is intentionally avoided; instead, objects reference each other using internal database IDs. This flat structure is reflected in the simplicity of the domain model's UML diagram. (Figure \ref{UML-domain-model}).

\paragraph{\textbf{Review class inheritance.}} The \texttt{Review} class is the core entity of the project. Given its dual nature within EduMeter, it has been divided into two specialized subclasses. The parent class is implemented as an abstract class; it is not intended for polymorphic use, but rather to provide a uniform structure for its children. \texttt{PublishedReview} and \texttt{DraftedReview} are the specific classes utilized by the resource managers.

\paragraph{\textbf{Response interface.}} The \texttt{response} sub-package was created to standardize the management of error messages, object creation confirmations, and system notifications. These records provide a consistent structure for resource manager responses. This allows the controller to select the appropriate message type for an HTTP request result, which is then easily translated by the JSON manager into a legible format.

\paragraph{\textbf{POJOs.}} Many project classes are implemented as POJOs (Plain Old Java Objects) to keep the code simple and easily interpretable by Jackson when deserializing parameters from HTTP requests. Consistency logic is implemented directly within the getters and setters of each class to ensure that field values remain valid.

\subsection{Business Logic}

This package is responsible for the heavy lifting of the backend's functional duties. The logic has been divided into three distinct components, each providing a fundamental service to the entire project: \textbf{authentication service}, \textbf{resource controllers} and \textbf{exception handlers}. These three packages actively engage with each other and with the ORM, which will be explored in section \ref{ORM-section}.

\subsubsection{Authentication and Authorization Service}
In EduMeter, users and admins needs to authenticate in order to perform their specific actions (publication and management). The authentication and authorization system is designed as a stateless, token-based security layer integrated into the JAX-RS request lifecycle. This design ensures secure communication and fine access control. Follows a description of all the structural decisions made by the team to implement this service. A detailed UML package diagram is also provided in Figure \ref{UML-auth}.

\paragraph{Declarative Security and Name Binding.} To secure REST endpoints, the system utilizes a declarative approach through custom annotations, making the code lighter and less repetitive, avoiding boiler plate control sequences. We have created 2 annotations:
\begin{itemize}
	\item \textbf{@AuthGuard}: Applied to resources requiring standard user authentication (e.g up-voting reviews and creating reviews).
	\item \textbf{@AdminGuard}: Applied to resources restricted to moderators (e.g. draft review and validation, report solving and behavioral countermeasures).
	\item \textbf{Name Binding}: Both annotations utilize the \texttt{@NameBinding} meta-annotation, allowing JAX-RS to associate specific filters with annotated resource methods.
\end{itemize}

\paragraph{Request Filtering and Context Injection.} The security workflow is managed by two primary providers that intercept incoming traffic:
\begin{itemize}
	\item \textbf{AuthFilter}: This component intercepts requests marked with \texttt{@AuthGuard}. It extracts the \texttt{Bearer} token (a digital "entry pass" that identifies a user and their permissions automatically, allowing the system to verify them without needing to check a database every time) from the \texttt{Authorization} header and initiates validation through the \texttt{CryptoService}. Upon successful verification, it injects a custom \texttt{SecurityContext} into the request, establishing the user principal and defining roles such as \texttt{ADMIN} or \texttt{BASE}.
	\item \textbf{AdminFilter}: This filter extends \texttt{AuthFilter} to handle \texttt{@AdminGuard} requirements. It first executes the base authentication logic via \texttt{super.filter()} and then performs a secondary check to ensure the authenticated principal possesses the \texttt{ADMIN} role. Failure to meet this requirement results in a \texttt{ForbiddenException} (HTTP 403).
\end{itemize}

\paragraph{The Cryptographic Engine (CryptoService).}
The \texttt{CryptoService} serves as a singleton utility responsible for the platform's cryptographic operations.
\begin{itemize}
	\item \textbf{JWT Custom Design}: The service implements a simplified version of the JSON Web Token (JWT) concept. To reduce overhead, the standard JWT header is omitted, resulting in a two-part token (instead of three-part) consisting of a Base64-encoded JSON payload and an HMAC-SHA256 signature.
	\item \textbf{Signature Verification}: Tokens are signed using the \texttt{HmacSHA256} algorithm and a server-side secret. Validation uses \texttt{MessageDigest.isEqual} to compare signatures, providing protection against timing attacks.
	\item \textbf{User Anonymization}: One of the core EduMeter's features is complete user anonymity. User's sensitive information are never visible to other users nor admins and are never stored directly into the DB. To protect privacy while maintaining database efficiency, the service generates a \texttt{userHash}. This is achieved by computing a 16-byte truncated version of an HMAC-SHA256 hash of the user's email, resulting in a unique 22-character Base64 identifier.
\end{itemize}

\begin{figure}
	\centering
	\begin{tikzpicture}[scale=0.7, transform shape]
		\umlclass[type= Jakarta interface, x=10, y=3]{ContainerRequestFilter}{}{}
		
		\begin{umlpackage}[y=-2]{auth}
			\begin{umlpackage}{annotations}
				\umlclass[type=@interface]{AuthGuard}{}{}
				\umlclass[right=2cm of AuthGuard, type=@interface]{AdminGuard}{}{}
			\end{umlpackage}
			
			\begin{umlpackage}[x=13, y=0]{filters}
				\umlclass{AuthFilter}{}{
					+ filter(...) : void
				}
				\umlclass[right=2cm of AuthFilter]{AdminFilter}{}{
					+ filter(...) : void
				}
			\end{umlpackage}
			
			\umlclass[x=12, y=-6, type = Singleton]{CryptoService}{
				\begin{tabular}{@{} l l @{}}
					-- static final TOKEN\_EXPIRE\_MINUTES & : long \\
					-- static final HMAC\_ALGO & : String           \\
					-- static instance & : CryptoSerice             \\
					-- final jsonMapper & : ObjectMapper            \\
					-- final mac & : Mac                            \\
					-- final revokedTokens & : Set<String>
				\end{tabular}
			}{
				\begin{tabular}{@{} l l @{}}
					-- CryptoService() & : CryptoService            \\
					+ static sync getInstance() & : CryptoService   \\
					+ generateToken(String, boolean) & : String     \\
					+ decodeToken(String) & : Token                 \\
					+ revokeToken(String) & : void                  \\
					+ getUserId(String) & : String 
				\end{tabular}         
			}
			
			\umlclass[x=2, y=-6,type=record]{Token}{
				\begin{tabular}{@{} l l @{}}
					+ userHash & : String \\
					+ expiresAt & : long \\
					+ isAdmin & : boolean 
				\end{tabular}
			}{}
		\end{umlpackage}
		
		\umlinherit[anchor1=west, anchor2=east]{AdminFilter}{AuthFilter}
		\umldep[anchor1=west, anchor2=east, stereo=use]{CryptoService}{Token}
		\umlimpl[geometry=-|]{AuthFilter}{ContainerRequestFilter}
	\end{tikzpicture}
	\caption{UML class diagram of the authentication package.}
	\label{UML-auth}
\end{figure}

\paragraph{Token Lifecycle and Security Constraints.}
\begin{itemize}
	\item \textbf{Expiration}: Tokens are generated with a strict 30-minute validity window.
	\item \textbf{Revocation}: A \texttt{revokedTokens} set is maintained to handle logout events or compromised tokens. While currently implemented using a \texttt{ConcurrentHashMap}, the service is designed for future migration to a Redis-based key store for persistent, distributed revocation management.
	\item \textbf{Secret Management}: The system requires a \texttt{SECRET} environment variable; if missing, it falls back to a randomly generated secure secret, ensuring that keys are invalidated upon every deployment for security.
\end{itemize}

\subsubsection{Resource Controllers} Resource controllers are responsible for HTTP request dispatching and resolution. This encompasses multiple tasks, including authentication management, exception handling, and database interaction for resource management. This layer represents the core of the backend, it glues the system components together and serves as the primary interface for client interaction. 


\paragraph{\textbf{Single Responsibility Principle.}} The controllers architecture has been designed to respect the single responsibility principle. Consequently, each controller is dedicated to managing only its specific resource, providing the necessary endpoints for user communication. Figure \ref{userControllerCode} demonstrates this approach through the \texttt{UserController} class. As a representative example, each controller is injected with only its corresponding Resource DAO, which serves as its sole point of data access. It is also clearly visible in Figure \ref{UML-controllers}, in each class attributes and in the fact that classes do not interact with each other.

\paragraph{\textbf{Class structure.}} Each class defines a collection of end-points all starting from a common root called \texttt{/source-name} (e.g., \texttt{/user} in this example). The narrower end-points characterize actions that user can perform on that path through an HTTP request. Different methods are annotated with different permission levels, some actions can be performed only by authenticated user or authenticated admins. This is perfectly visible on top of the method signature, along with all the other specific annotations enabling data emission or insertion. Every method concludes by returning a structured message to the client.

\begin{lstlisting}[language=Java, caption=Example of User controller class, label=userControllerCode]
	@Path("/user")
	public class UserController {
		private final UserDAO userDAO;
		@Inject
		public UserController(UserDAO userDAO) {
			this.userDAO = userDAO;
		}
		
		@GET
		@Produces(MediaType.APPLICATION_JSON)
		@AdminGuard
		public List<User> search(@QueryParam("banned") Boolean banned) {
			return userDAO.search(banned);
		}
		
		@POST
		@Path("/{user_hash}/ban")
		@Produces(MediaType.APPLICATION_JSON)
		@AdminGuard
		public ApiOk ban(@PathParam("user_hash") String userHash) {
			User u = userDAO.get(userHash)
			.orElseThrow(() -> new NotFoundException("User not found"));
			u.setBanned(true);
			
			userDAO.update(u);
			
			return new ApiOk("User banned");
		}
		
	}
\end{lstlisting}

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[scale=0.6, transform shape]
		\begin{umlpackage}{controllers}
			\umlclass{AdminController}{
				- adminDAO : AdminDAO \\
			}{
			    \begin{tabular}{@{} l l @{}}
			    	+ getAll() & : List<Admin> \\
			    	+ get(int) & : Admin \\
			    	+ create(Admin) & : ApiObjectCreated \\
			    	+ delete(int) & : ApiOK 
			    \end{tabular}
				
			}
			
			\umlclass[right=0.7cm of AdminController]{UserController}{
				+ userDAO : UserDAO \\
			}{
				\begin{tabular}{@{} l l @{}}
					+ search(Boolean) & : List<User> \\
					+ getByHash(SecurityContext) & : User \\
					+ ban(String) & : Boolean \\
				\end{tabular}
			}
			
			\umlclass[right=0.7cm of UserController]{AuthController}{
				\begin{tabular}{@{} l l @{}}
					+ \underline{WHITELISTED\_DOMAINS} & : String \\
					+ \underline{PIN\_EXPIRATION\_MIN} & : int \\
					-- pinDAO & : PinDAO \\
					-- adminDAO & : AdminDAO \\
					-- record SendPinBody(String) & \\
					-- record LoginBody(String, String) & \\
					-- record LoginResponse(String) & 
				\end{tabular}
			}{
				\begin{tabular}{@{} l l @{}}
					+ sendPin(boolean, SendPinBody) & : ApiOK \\
					+ login(boolean, LoginBody) & : LogicResponse \\
					+ logout(String) & : ApiOK
				\end{tabular}
			}
			
			\umlclass[x=4, y=-12]{ReportController}{
				\begin{tabular}{@{} l l @{}}
					-- reportDAO & : ReportDAO \\
					-- userDAO & : UserDAO
				\end{tabular}
			}{
				\begin{tabular}{@{} l l @{}}
					+ getAll() & : List<Report> \\
					+ get(int) & : Report \\
					+ create(SecurityContext, Report) & : CreateResponse \\
					+ acceptReport(int,Boolean) & : void
				\end{tabular}
			}
			
			\umlclass[x=0.5, y=-6]{DegreeController}{
				-- degreeDAO : DegreeDAO
			}{
				\begin{tabular}{@{} l l @{}}
					+ search(String, Integer) & : List<Degree> \\
					+ get(int) & : Degree \\
					+ create(Degree) & : CreateResponse \\
					+ delete(int) & : ApiOK \\
					+ update(Degree) & : ApiOK
				\end{tabular}
			}
			
			\umlclass[right=0.5cm of DegreeController,y=-3]{SchoolController}{
				-- schoolDAO : SchoolDAO
			}{
				\begin{tabular}{@{} l l @{}}
					+ search(String) & : List<School> \\
					+ get(int) & : School \\
					+ create(School) & : CreateResponse \\
					+ delete(int) & : ApiOK \\
					+ update(School) & : ApiOK
				\end{tabular}
			}
			
			\umlclass[right=0.5cm of SchoolController, y=-3]{CourseController}{
				-- courselDAO : courseDAO
			}{
				\begin{tabular}{@{} l l @{}}
					+ search(String, Integer, Integer) & : List<Course> \\
					+ get(int) & : Course \\
					+ create(Course) & : CreateResponse \\
					+ delete(int) & : ApiOK \\
					+ update(Course) & : ApiOK
				\end{tabular}
			}
			
			\umlclass[right=2cm of ReportController]{ProfessorController}{
				\begin{tabular}{@{} l l @{}}
					-- profDAO & : ProfDAO \\
					-- teachingDAO & : TeachingDAO
				\end{tabular}
			}{
				\begin{tabular}{@{} l l @{}}
					+ search(String, Integer) & : List<Professor> \\
					+ get(int) & : Professor \\
					+ create(Professor) & : ApiObjectCreated \\
					+ delete(int) & : ApiOk \\
					+ update(Professor) & : ApiOk \\
					+ listTeachings(int) & : List<Teaching>
				\end{tabular}
			}
			
			\umlclass[x=3,y=-18]{PublishedReviewController}{
				+ publishedReviewDAO : PublishedReviewDAO
			}{
				\begin{tabular}{@{} l l @{}}
					+ search(Integer, ..., Integer, ContainerRequestContext) & : List<T> \\
					+ get(int, ContainerRequestContext) & : PublishedReview \\
					+ publish(PublishedReview, SecurityContext) & : ApiObjectCreated \\
					+ toggleVote(int, ContainerRequestContext) & : ApiOk \\
					+ delete(int, ContainerRequestContext) & : ApiOk \\
					+ update(PublishedReview, ContainerRequestContext) & : ApiOk \\
				\end{tabular}
			}
			
			\umlclass[right=2cm of PublishedReviewController,y=-6]{DraftReviewController}{
				-- reviewDAO : DraftReviewDAO
			}{
				\begin{tabular}{@{} l l @{}}
					+ getAll() & : List<DraftReview> \\
					+ get(int) &  : DraftReview \\
					+ publish(DraftReview, SecurityContext) & : ApiObjectCreated \\
					+ delete(int) & : ApiOk
				\end{tabular}
			}
			
		\end{umlpackage}
	\end{tikzpicture}
	\caption{UML class diagram of the resource controllers package.}
	\label{UML-controllers}
\end{figure}

\subsubsection{Exception Handlers} The \textbf{Exception Handlers} package is a fundamental component of the \textit{EduMeter} architecture, responsible for ensuring system robustness and providing a consistent interface for error reporting.

\paragraph{\textbf{Standardized Error Reporting.}} To prevent the leakage of sensitive internal state and to provide a predictable API for client-side consumption, this package intercepts all application-level exceptions and translates them into a standardized JSON format: \texttt{\{"error":"description of the issue"\}}. This mechanism ensures that the backend never returns default HTML error pages.

\paragraph{\textbf{Specialized Exception Mappers.}} The package utilizes the Jakarta \texttt{ExceptionMapper} interface to provide in-depth control over different error scenarios:

\begin{itemize}
	\item \textbf{Global Exception Handler}: Acts as a universal safety net for any \texttt{Throwable} not caught by more specific mappers. It preserves the HTTP status codes for \texttt{WebApplicationExceptions} while mapping all other unforeseen errors to HTTP 500 (Internal Server Error).
	\item \textbf{JSON Validation Mappers}: Specialized mappers such as \texttt{JsonParseExceptionHandler} and \texttt{UnrecognizedPropertyExceptionHandler} handle errors related to request payloads. These mappers return HTTP 400 (Bad Request), providing specific feedback when a client sends malformed JSON or invalid data fields.
\end{itemize}

The exception handling in JAX-RS operates through a hierarchical discovery process that prioritizes the most specific match available to resolve a failure. When an error occurs, the runtime builds a map of all classes annotated with \texttt{@Provider} and searches for an ExceptionMapper that matches the thrown exception type, starting from the most narrow "leaf" class and moving up the inheritance tree toward more general types. In the \textit{EduMeter} implementation, this allows specialized handlers to capture precise issues, such as malformed data or unrecognized fields, and provide detailed feedback with an HTTP 400 status. If no specific mapper is found, the system falls back to a global Throwable handler that serves as a safety net, ensuring that even unforeseen internal errors are caught and translated into a standardized JSON response rather than exposing raw system details.

\begin{figure}
	\centering
	\begin{tikzpicture}[scale=0.8, transform shape]
		
		\umlclass[x=-4, y=6]{ExceptionMapper<Throwable>}{}{}
		\umlclass[x=5, y=6]{ExceptionMapper<InvalidFormat>}{}{}
		
		\umlclass[x=-4, y=-5]{ExceptionMapper<JsonParseException>}{}{}
		\umlclass[x=6, y=-5]{ExceptionMapper<UnrecognizedPropertyException>}{}{}
		
		\begin{umlpackage}[x=0.5, y=-8]{exceptionHandlers}
			
			\umlclass[x=-4.5, y=10]{ExceptionHandler}
			{}
			{+ toResponse(Throwable) : Response}
			
			\umlclass[x=4.5, y=10]{InvalidFormatExceptionHandler}
			{}
			{+ toResponse(Throwable) : Response}
			
			\umlclass[x=-4.5, y=7]{JsonParseExceptionHandler}
			{}
			{+ toResponse(Throwable) : Response}
			
			\umlclass[x=4.5, y=7]{UnrecognizedPropertyExceptionHandler}
			{}
			{+ toResponse(Throwable) : Response}
			
			\umlinherit[geometry=|-|, anchor1=30, anchor2=-50]{ExceptionHandler}{ExceptionMapper<Throwable>}
			\umlinherit{InvalidFormatExceptionHandler}{ExceptionMapper<InvalidFormat>}
			\umlinherit{JsonParseExceptionHandler}{ExceptionMapper<JsonParseException>}
			\umlinherit[geometry=|-|]{UnrecognizedPropertyExceptionHandler}{ExceptionMapper<UnrecognizedPropertyException>}
			
		\end{umlpackage}
		
	\end{tikzpicture}
	\label{UML-exceptin-handling}
	\caption{UML class diagram of the exception handling package.}
\end{figure}

\paragraph{\textbf{Approach Advantages.}} Implementing multiple specialized mappers instead of a single general safety net provides several engineering advantages:
\begin{itemize}
	\item \textbf{Precise Client Feedback}: Clients receive exact details about validation errors (such as the specific unrecognized field name) rather than a vague "Internal Error".
	\item \textbf{Semantic HTTP Accuracy}: This approach ensures that client-side mistakes correctly return HTTP 400 (Bad Request) codes, whereas a single safety net might incorrectly categorize them as 500 (Internal Server Error).
	\item \textbf{Security and Sanitization}: Specific mappers allow for "sanitizing" error messages to ensure that internal database structures or logic are not leaked, while the general handler prevents the exposure of raw stack traces.
	\item \textbf{Operational Efficiency}: Decoupling error handling from business logic allows core services to focus on the "happy path," while the provider architecture automatically manages the complexity of error translation at the edge of the application.
\end{itemize}

\subsection{Object-Relation Mapper (ORM)} \label{ORM-section}

\subsubsection{DAO Interfaces}

\begin{figure}
	\centering
	\begin{tikzpicture}[scale=0.7, transform shape]
		\begin{umlpackage}{ORM}
			\umlclass[type=interface]{DAOFactory}{}{
				\begin{tabular}{@{} l l @{}}
					... & ... \\
					+ getDegreeDAO() & : DegreeDAO \\
					... & ...
				\end{tabular}
			}
			\umlclass[type=interface, right=3.5cm of DAOFactory]{AdminDAO}{}{
				\begin{tabular}{@{} l l @{}}
					+ get(int) & : Optional<Admin> \\
					+ getByEmail(String) & : Optional<Admin> \\
					+ getAll() & : List<Admin> \\
					+ delete(int) & : void \\
					+ add(Admin) & : int 
				\end{tabular}
			}
			\umlclass[x=7.5, y=-5]{InMemAdminDAO}{}{}
			\umlclass[right=2.16cm of InMemAdminDAO]{PostgreAdminDAO}{}{}
			
			\umlclass[type=interface, x=7.5, y=-8]{InMemDAOFactory}{}{}
			\umlclass[type=interface, right=2cm of InMemDAOFactory]{PostgreDAOFactory}{}{}
			
		\end{umlpackage}
		
		\umldep[geometry=|-|]{InMemDAOFactory}{InMemAdminDAO}
		\umldep[geometry=|-|]{PostgreDAOFactory}{PostgreAdminDAO}
		\umldep[anchor1=east, anchor2=west]{DAOFactory}{AdminDAO}
		
		\umlinherit[geometry=|-|, arm1=1, anchor1=north]{InMemAdminDAO}{AdminDAO}
		\umlinherit[geometry=|-|, arm1=1, anchor1=north]{PostgreAdminDAO}{AdminDAO}
		
		\umlinherit[geometry=|-|, anchor1=south, arm1=-0.3]{InMemDAOFactory}{DAOFactory}
		\umlinherit[geometry=|-|, anchor1=south, arm1=-0.3]{PostgreDAOFactory}{DAOFactory}
	\end{tikzpicture}
	\caption{Partial UML class diagram of the ORM package. This diagram display only the portion related to the Admin resource, the part referred to the other resources have the exact layout, therefore, it is omitted.}
	\label{UML-ORM}
\end{figure}

\subsubsection{In Memory Storage}

\subsubsection{Postgre Remote Storage}

\subsection{Database}
When the remote storage option is selected, the application relies on a PostgreSQL database to ensure reliable and persistent data storage. This database must be instantiated on the host environment and properly configured to interact seamlessly with the application back-end.

\subsubsection{Connection}
The connection to the database is managed by a dedicated class: \texttt{DatabaseManager}. This class is structured using the Singleton design pattern to ensure that only a single instance manages database connectivity throughout the application's lifecycle. Access to this instance is controlled via a synchronized \texttt{getInstance()} method, ensuring thread safety even in concurrent environments.

To handle communication with the database, the class provides a \texttt{getConnection()} method. This method optimizes resource usage by first checking if an active connection already exists; if the connection is null or closed, it proceeds to establish a new one.
 
To establish the connection three variable must be set: 
\begin{itemize}
	\item \texttt{DB\_URL}: The connection string that tells the JDBC driver where your database is hosted and which specific database instance to connect to. It follows the format:\\ \texttt{jdbc:postgresql://host:port/database\_name}.
	\item \texttt{DB\_USER}: This is the username of the PostgreSQL account that can access, initialize, and modify the database.
	\item \texttt{DB\_PASSWORD}: The database password related to the user.
\end{itemize}
For security and deployment flexibility, credentials are never hardcoded; instead, they are memorized as environment variable and the \texttt{DatabaseManager} dynamically retrieves them when necessary. If any of these essential variables are missing, the system immediately halts the process by throwing an \texttt{IllegalStateException}. 

Once the environment variables are successfully validated, the manager loads the PostgreSQL JDBC driver (\texttt{org.postgresql.Driver}) and establishes the connection through the \texttt{DriverManager}.

\subsubsection{Structure}
\paragraph{Initialization}
When the remote storage option is active and \texttt{PostgreDAOFactory} is instantiated, the database schema is automatically initialized. The factory's constructor triggers an \texttt{initDatabase()} method, which reads an \textit{init.sql} file located in the application's resources folder. The factory requests a connection from the \texttt{DatabaseManager} and executes the script as a single query string.

This automated setup process is inherently safe and idempotent. All queries within the \textit{init.sql} script utilize the \texttt{CREATE TABLE IF NOT EXISTS} clause, ensuring that existing data or structures are never accidentally overwritten if the database has already been configured. 

\paragraph{Implementation}
The database has been structured following the relational Entity-Relationship schema in Figure \ref{ER model}. The architecture is built around several interconnected core entities:
\begin{itemize}
	\item \textbf{Users \& Authentication:} The \texttt{Users} table manages standard accounts (including ban status), while administrative access is handled by the \texttt{Admin} table. Authentication and password recovery rely on a \texttt{Pin} table, which stores temporary codes, their expiration timestamps, and the user's administrative status.
	\item \textbf{Academic Hierarchy:} The educational structure is represented by linking \texttt{School}, \texttt{Degree}, \texttt{Course}, and \textbf{Professor} tables. A central associative entity, \texttt{Teaching}, acts as a bridge to associate specific professors with specific courses.
	\item \textbf{Review System:} The core functionality revolves around the \texttt{Published Review} and \texttt{Drafted Review} tables. Published reviews are linked to a specific \texttt{Teaching} instance and a \texttt{User}, storing rating, difficulty, and text comments. Drafts contain similar, though less strictly constrained, information before final submission.
	\item \textbf{Interaction \& Moderation:} To support community features, an \texttt{Up Vote} table tracks which users have liked specific reviews. Additionally, a \texttt{Report} table allows users to flag problematic reviews, linking the report comment directly to the user and the review in question.
\end{itemize}


\begin{figure}[H]
	\centering
	\begin{tikzpicture}[scale=0.8, transform shape]

		\umlclass{Users}{
			\begin{tabular}{@{} l l l @{}}
				\textbf{PK} & \textbf{id} 	& \textit{char} \\
							& banned 		& \textit{boolean}
			\end{tabular}
		}

		\umlclass[below = 1cm of Users]{Published Review}{
			\begin{tabular}{@{} l l l @{}}
				\textbf{PK} & \textbf{id} 	& \textit{int} \\
				\textbf{FK} & user\_id 		& \textit{int} \\
							& date			& \textit{date} \\
				\textbf{FK} & teaching\_id 	& \textit{int} \\
							& rating		& \textit{int} \\
							& difficulty  	& \textit{int} \\
							& comment 		& \textit{text} \\
			\end{tabular}
		}

		\umlclass[below = 1cm of Published Review]{Teaching}{
			\begin{tabular}{@{} l l l @{}}
				\textbf{PK} & \textbf{id}	& \textit{id} \\
				\textbf{FK} & course\_id 	& \textit{int} \\
				\textbf{FK} & professor\_id & \textit{int} \\
			\end{tabular}
		}

		\umlclass[above = 1cm of Users]{Pin}{
			\begin{tabular}{@{} l l l @{}}
				\textbf{PK} & \textbf{id} 	& \textit{int} \\
							& pin	 		& \textit{varchar} \\
				\textbf{FK} & user\_id 		&\textit{char} \\
							& expires\_at 	&\textit{timestamp} \\
							& is\_admin 	&\textit{boolean}
			\end{tabular}
		}

		\umlclass[left = 1.5cm of Users]{Drafted Review}{
			\begin{tabular}{@{} l l l @{}}
				\textbf{PK} & \textbf{id} 	& \textit{int} \\
				\textbf{FK} & user\_id 		& \textit{char} \\
							& date 			& \textit{date} \\
							& school 		& \textit{varchar} \\
							& degree 		& \textit{varchar} \\
							& course 		& \textit{varchar} \\
							& professor		& \textit{varchar} \\
							& rating 		& \textit{int} \\
							& difficulty 	& \textit{int} \\
							& comment		& \textit{varchar} \\
			\end{tabular}
		}

		\umlclass[above = 1cm of Drafted Review]{Admin}{
			\begin{tabular}{@{} l l l @{}}
				\textbf{PK} & \textbf{id} 	& \textit{int} \\
							& email			& \textit{varchar} \\
			\end{tabular}
		}

		\umlclass[below = 0.5cm of Drafted Review]{Up Vote}{
			\begin{tabular}{@{} l l l @{}}
				\textbf{PK FK} & \textbf{user\_id}   & \textit{char} \\
				\textbf{PK FK} & \textbf{review\_id} & \textit{int} \\
			\end{tabular}
		}

		\umlclass[left = 1.5cm of Teaching]{Professor}{
			\begin{tabular}{@{} l l l @{}}
				\textbf{PK} & \textbf{id} 	& \textit{int} \\
							& name 			& \textit{varchar} \\
							& surname		& \textit{varchar} \\
			\end{tabular}
		}

		\umlclass[right = 1.5cm of Teaching]{Course}{
			\begin{tabular}{@{} l l l @{}}
				\textbf{PK} & \textbf{id} 	& \textit{int} \\
							& name 			& \textit{varchar} \\
				\textbf{FK} & degree\_id 	& \textit{int} \\
			\end{tabular}
		}

		\umlclass[above = 1cm of Course]{Degree}{
			\begin{tabular}{@{} l l l @{}}
				\textbf{PK} & \textbf{id} 	& \textit{int} \\
							& name 			& \textit{varchar} \\
							& type 			& \textit{varchar} \\
				\textbf{FK} & school\_id 	& \textit{int} \\
			\end{tabular}
		}

		\umlclass[above = 1cm of Degree]{School}{
			\begin{tabular}{@{} l l l @{}}
				\textbf{PK} & \textbf{id} 	& \textit{int} \\
							& name 			& \textit{varchar} \\
			\end{tabular}
		}

		\umlclass[above = 2cm of School]{Report}{
			\begin{tabular}{@{} l l l @{}}
				\textbf{PK} & \textbf{id} 	& \textit{int} \\
							& comment		& \textit{varchar} \\
							& date 			& \textit{date} \\
				\textbf{FK} & user\_id 		& \textit{char} \\
				\textbf{FK} & review\_id 	& \textit{int}
			\end{tabular}
		}

		\umluniassoc{Report}{Users}
		\umluniassoc{Report}{Published Review}
		\umluniassoc{Drafted Review}{Users}
		\umluniassoc{Published Review}{Users}
		\umluniassoc{Course}{Degree}
		\umluniassoc{Degree}{School}
		\umluniassoc{Teaching}{Course}
		\umluniassoc{Teaching}{Professor}
		\umluniassoc{Published Review}{Teaching}
		\umluniassoc{Pin}{Users}
		\umluniassoc{Up Vote}{Users}
		\umluniassoc{Up Vote}{Published Review}

	\end{tikzpicture}
	\caption{UML diagram of Database schema.}
\end{figure}

\subsection{Interface}
